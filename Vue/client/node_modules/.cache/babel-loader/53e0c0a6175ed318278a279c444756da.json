{"ast":null,"code":"import _objectSpread from \"D:/Stage/App/xr-place-application/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _typeof from \"D:/Stage/App/xr-place-application/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _createForOfIteratorHelper from \"D:/Stage/App/xr-place-application/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.object.keys.js\";\n\n/* eslint-disable max-statements */\n\n/* eslint-disable no-labels */\n// Utilities\nimport { getPropertyFromItem, propsFactory, wrapInArray } from \"../util/index.mjs\";\nimport { computed, unref } from 'vue'; // Types\n// Composables\n\nexport var defaultFilter = function defaultFilter(value, query, item) {\n  if (value == null || query == null) return -1;\n  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());\n};\nexport var makeFilterProps = propsFactory({\n  customFilter: Function,\n  customKeyFilter: Object,\n  filterKeys: [Array, String],\n  filterMode: {\n    type: String,\n    \"default\": 'intersection'\n  },\n  noFilter: Boolean\n}, 'filter');\nexport function filterItems(items, query, options) {\n  var _options$default, _options$customKeyFil;\n\n  var array = []; // always ensure we fall back to a functioning filter\n\n  var filter = (_options$default = options == null ? void 0 : options[\"default\"]) != null ? _options$default : defaultFilter;\n  var keys = options != null && options.filterKeys ? wrapInArray(options.filterKeys) : false;\n  var customFiltersLength = Object.keys((_options$customKeyFil = options == null ? void 0 : options.customKeyFilter) != null ? _options$customKeyFil : {}).length;\n  if (!(items != null && items.length)) return array;\n\n  var _iterator = _createForOfIteratorHelper(items),\n      _step;\n\n  try {\n    loop: for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      var customMatches = {};\n      var defaultMatches = {};\n      var match = -1;\n\n      if (query && _typeof(item) === 'object' && !(options != null && options.noFilter)) {\n        var filterKeys = keys || Object.keys(item);\n\n        var _iterator2 = _createForOfIteratorHelper(filterKeys),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var key = _step2.value;\n\n            var _options$customKeyFil2;\n\n            var value = getPropertyFromItem(item, key, item);\n            var keyFilter = options == null ? void 0 : (_options$customKeyFil2 = options.customKeyFilter) == null ? void 0 : _options$customKeyFil2[key];\n            match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);\n\n            if (match !== -1 && match !== false) {\n              if (keyFilter) customMatches[key] = match;else defaultMatches[key] = match;\n            } else if ((options == null ? void 0 : options.filterMode) === 'every') {\n              continue loop;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        var defaultMatchesLength = Object.keys(defaultMatches).length;\n        var customMatchesLength = Object.keys(customMatches).length;\n        if (!defaultMatchesLength && !customMatchesLength) continue;\n        if ((options == null ? void 0 : options.filterMode) === 'union' && customMatchesLength !== customFiltersLength && !defaultMatchesLength) continue;\n        if ((options == null ? void 0 : options.filterMode) === 'intersection' && (customMatchesLength !== customFiltersLength || !defaultMatchesLength)) continue;\n      }\n\n      array.push({\n        item: item,\n        matches: _objectSpread(_objectSpread({}, defaultMatches), customMatches)\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return array;\n}\nexport function useFilter(props, items, query) {\n  var strQuery = computed(function () {\n    return typeof (query == null ? void 0 : query.value) !== 'string' && typeof (query == null ? void 0 : query.value) !== 'number' ? '' : String(query.value);\n  });\n  var filteredItems = computed(function () {\n    return filterItems(unref(items), strQuery.value, {\n      customKeyFilter: props.customKeyFilter,\n      \"default\": props.customFilter,\n      filterKeys: props.filterKeys,\n      filterMode: props.filterMode,\n      noFilter: props.noFilter\n    });\n  });\n  return {\n    filteredItems: filteredItems\n  };\n}","map":{"version":3,"mappings":"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","names":["getPropertyFromItem","propsFactory","wrapInArray","computed","unref","defaultFilter","value","query","item","toString","toLocaleLowerCase","indexOf","makeFilterProps","customFilter","Function","customKeyFilter","Object","filterKeys","Array","String","filterMode","type","default","noFilter","Boolean","filterItems","items","options","array","filter","keys","customFiltersLength","length","loop","customMatches","defaultMatches","match","key","keyFilter","_options$customKeyFil2","defaultMatchesLength","customMatchesLength","push","matches","useFilter","props","strQuery","filteredItems"],"sources":["../../src/composables/filter.ts"],"sourcesContent":["/* eslint-disable max-statements */\n/* eslint-disable no-labels */\n\n// Utilities\nimport { getPropertyFromItem, propsFactory, wrapInArray } from '@/util'\nimport { computed, unref } from 'vue'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { MaybeRef } from '@/util'\n\nexport type FilterFunction = (value: string, query: string, item?: any) => FilterMatch\nexport type FilterKeyFunctions = Record<string, FilterFunction>\nexport type FilterKeys = string | string[]\nexport type FilterMatch = number | [number, number] | [number, number][] | boolean\nexport type FilterMode = 'some' | 'every' | 'union' | 'intersection'\n\nexport interface FilterProps {\n  customFilter?: FilterFunction\n  customKeyFilter?: FilterKeyFunctions\n  filterKeys?: FilterKeys\n  filterMode?: FilterMode\n  noFilter?: boolean\n}\n\n// Composables\nexport const defaultFilter: FilterFunction = (value, query, item) => {\n  if (value == null || query == null) return -1\n\n  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase())\n}\n\nexport const makeFilterProps = propsFactory({\n  customFilter: Function as PropType<FilterFunction>,\n  customKeyFilter: Object as PropType<FilterKeyFunctions>,\n  filterKeys: [Array, String] as PropType<FilterKeys>,\n  filterMode: {\n    type: String as PropType<FilterMode>,\n    default: 'intersection',\n  },\n  noFilter: Boolean,\n}, 'filter')\n\nexport function filterItems<T = Record<string, any>> (\n  items: T[],\n  query: string,\n  options?: {\n    customKeyFilter?: FilterKeyFunctions\n    default?: FilterFunction\n    filterKeys?: FilterKeys\n    filterMode?: FilterMode\n    noFilter?: boolean\n  },\n) {\n  const array: { item: T, matches: Record<string, FilterMatch> }[] = []\n  // always ensure we fall back to a functioning filter\n  const filter = options?.default ?? defaultFilter\n  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false\n  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length\n\n  if (!items?.length) return array\n\n  loop:\n  for (const item of items) {\n    const customMatches: Record<string, FilterMatch> = {}\n    const defaultMatches: Record<string, FilterMatch> = {}\n    let match: FilterMatch = -1\n\n    if (query && typeof item === 'object' && !options?.noFilter) {\n      const filterKeys = keys || Object.keys(item)\n\n      for (const key of filterKeys) {\n        const value = getPropertyFromItem(item as any, key, item)\n        const keyFilter = options?.customKeyFilter?.[key]\n\n        match = keyFilter\n          ? keyFilter(value, query, item)\n          : filter(value, query, item)\n\n        if (match !== -1 && match !== false) {\n          if (keyFilter) customMatches[key] = match\n          else defaultMatches[key] = match\n        } else if (options?.filterMode === 'every') {\n          continue loop\n        }\n      }\n\n      const defaultMatchesLength = Object.keys(defaultMatches).length\n      const customMatchesLength = Object.keys(customMatches).length\n\n      if (!defaultMatchesLength && !customMatchesLength) continue\n\n      if (\n        options?.filterMode === 'union' &&\n        customMatchesLength !== customFiltersLength &&\n        !defaultMatchesLength\n      ) continue\n\n      if (\n        options?.filterMode === 'intersection' &&\n        (\n          customMatchesLength !== customFiltersLength ||\n          !defaultMatchesLength\n        )\n      ) continue\n    }\n\n    array.push({ item, matches: { ...defaultMatches, ...customMatches } })\n  }\n\n  return array\n}\n\nexport function useFilter<T> (\n  props: FilterProps,\n  items: MaybeRef<T[]>,\n  query?: Ref<string | undefined>,\n) {\n  const strQuery = computed(() => (\n    typeof query?.value !== 'string' &&\n    typeof query?.value !== 'number'\n  ) ? '' : String(query.value))\n\n  const filteredItems = computed(() => {\n    return filterItems(\n      unref(items),\n      strQuery.value,\n      {\n        customKeyFilter: props.customKeyFilter,\n        default: props.customFilter,\n        filterKeys: props.filterKeys,\n        filterMode: props.filterMode,\n        noFilter: props.noFilter,\n      },\n    )\n  })\n\n  return { filteredItems }\n}\n"]},"metadata":{},"sourceType":"module"}