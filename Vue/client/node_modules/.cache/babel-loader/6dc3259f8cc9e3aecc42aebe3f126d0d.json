{"ast":null,"code":"import _slicedToArray from \"D:/Stage/App/xr-place-application/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nvar block = ['top', 'bottom'];\nvar inline = ['start', 'end'];\n/** Parse a raw anchor string into an object */\n\nexport function parseAnchor(anchor) {\n  var _anchor$split = anchor.split(' '),\n      _anchor$split2 = _slicedToArray(_anchor$split, 2),\n      side = _anchor$split2[0],\n      align = _anchor$split2[1];\n\n  if (!align) {\n    align = side === 'top' || side === 'bottom' ? 'start' : side === 'start' || side === 'end' ? 'top' : 'center';\n  }\n\n  return {\n    side: side,\n    align: align\n  };\n}\n/** Get an anchor directly opposite, with the same alignment */\n\nexport function oppositeAnchor(anchor) {\n  return {\n    side: {\n      center: 'center',\n      top: 'bottom',\n      bottom: 'top',\n      start: 'end',\n      end: 'start'\n    }[anchor.side],\n    align: anchor.align\n  };\n}\n/** Convert start/end into left/right */\n\nexport function physicalAnchor(anchor, el) {\n  var _map$side, _map$align;\n\n  var side = anchor.side,\n      align = anchor.align;\n\n  var _window$getComputedSt = window.getComputedStyle(el),\n      direction = _window$getComputedSt.direction;\n\n  var map = direction === 'ltr' ? {\n    start: 'left',\n    end: 'right'\n  } : {\n    start: 'right',\n    end: 'left'\n  };\n  return ((_map$side = map[side]) != null ? _map$side : side) + ' ' + ((_map$align = map[align]) != null ? _map$align : align);\n}","map":{"version":3,"mappings":";;;AAAA,IAAMA,KAAK,GAAG,CAAC,KAAD,EAAQ,QAAR,CAAd;AACA,IAAMC,MAAM,GAAG,CAAC,OAAD,EAAU,KAAV,CAAf;AAeA;;AACA,OAAO,SAASC,WAAT,CAAsBC,MAAtB,EAAsC;AAC3C,sBAAoBA,MAAM,CAACC,KAAPD,CAAa,GAAbA,CAApB;AAAA;AAAA,MAAKE,IAAL;AAAA,MAAWC,KAAX;;AACA,MAAI,CAACA,KAAL,EAAY;AACVA,SAAK,GACHD,IAAI,KAAK,KAATA,IAAkBA,IAAI,KAAK,QAA3BA,GAAsC,OAAtCA,GACEA,IAAI,KAAK,OAATA,IAAoBA,IAAI,KAAK,KAA7BA,GAAqC,KAArCA,GACA,QAHJC;AAID;;AACD,SAAO;AACLD,QADK,EACLA,IADK;AAELC;AAFK,GAAP;AAID;AAED;;AACA,OAAO,SAASC,cAAT,CAAyBJ,MAAzB,EAA+C;AACpD,SAAO;AACLE,QAAI,EAAE;AACJG,YAAM,EAAE,QADJ;AAEJC,SAAG,EAAE,QAFD;AAGJC,YAAM,EAAE,KAHJ;AAIJC,WAAK,EAAE,KAJH;AAKJC,SAAG,EAAE;AALD,MAMJT,MAAM,CAACE,IANH,CADD;AAQLC,SAAK,EAAEH,MAAM,CAACG;AART,GAAP;AAUD;AAED;;AACA,OAAO,SAASO,cAAT,CAAyBV,MAAzB,EAA+CW,EAA/C,EAAgE;AAAA;;AACrE,MAAQT,IAAR,GAAwBF,MAAxB,CAAQE,IAAR;AAAA,MAAcC,KAAd,GAAwBH,MAAxB,CAAcG,KAAd;;AACA,8BAAsBS,MAAM,CAACC,gBAAPD,CAAwBD,EAAxBC,CAAtB;AAAA,MAAQE,SAAR,yBAAQA,SAAR;;AAEA,MAAMC,GAAuC,GAAGD,SAAS,KAAK,KAAdA,GAAsB;AACpEN,SAAK,EAAE,MAD6D;AAEpEC,OAAG,EAAE;AAF+D,GAAtBK,GAG5C;AACFN,SAAK,EAAE,OADL;AAEFC,OAAG,EAAE;AAFH,GAHJ;AAQA,SAAO,cAACM,GAAG,CAACb,IAAD,CAAJ,wBAAcA,IAAd,IAAsB,GAAtB,kBAA6Ba,GAAG,CAACZ,KAAD,CAAhC,yBAA2CA,KAA3C,CAAP;AACD","names":["block","inline","parseAnchor","anchor","split","side","align","oppositeAnchor","center","top","bottom","start","end","physicalAnchor","el","window","getComputedStyle","direction","map"],"sources":["../../../../src/components/VOverlay/util/anchor.ts"],"sourcesContent":["const block = ['top', 'bottom'] as const\nconst inline = ['start', 'end'] as const\ntype Tblock = typeof block[number]\ntype Tinline = typeof inline [number]\nexport type Anchor =\n  | Tblock\n  | Tinline\n  | 'center'\n  | 'center center'\n  | `${Tblock} ${Tinline | 'center'}`\n  | `${Tinline} ${Tblock | 'center'}`\nexport type ParsedAnchor =\n  | { side: 'center', align: 'center' }\n  | { side: Tblock, align: Tinline | 'center' }\n  | { side: Tinline, align: Tblock | 'center' }\n\n/** Parse a raw anchor string into an object */\nexport function parseAnchor (anchor: Anchor) {\n  let [side, align] = anchor.split(' ')\n  if (!align) {\n    align =\n      side === 'top' || side === 'bottom' ? 'start'\n      : side === 'start' || side === 'end' ? 'top'\n      : 'center'\n  }\n  return {\n    side,\n    align,\n  } as ParsedAnchor\n}\n\n/** Get an anchor directly opposite, with the same alignment */\nexport function oppositeAnchor (anchor: ParsedAnchor) {\n  return {\n    side: {\n      center: 'center',\n      top: 'bottom',\n      bottom: 'top',\n      start: 'end',\n      end: 'start',\n    }[anchor.side],\n    align: anchor.align,\n  } as ParsedAnchor\n}\n\n/** Convert start/end into left/right */\nexport function physicalAnchor (anchor: ParsedAnchor, el: HTMLElement) {\n  const { side, align } = anchor\n  const { direction } = window.getComputedStyle(el)\n\n  const map: Record<string, string | undefined> = direction === 'ltr' ? {\n    start: 'left',\n    end: 'right',\n  } : {\n    start: 'right',\n    end: 'left',\n  }\n\n  return (map[side] ?? side) + ' ' + (map[align] ?? align)\n}\n"]},"metadata":{},"sourceType":"module"}