{"ast":null,"code":"import _objectSpread from \"D:/Stage/App/xr-place-application/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"D:/Stage/App/xr-place-application/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/Stage/App/xr-place-application/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _typeof from \"D:/Stage/App/xr-place-application/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _toConsumableArray from \"D:/Stage/App/xr-place-application/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport { useProxiedModel } from \"../proxiedModel.mjs\";\nimport { getCurrentInstance, getUid, propsFactory } from \"../../util/index.mjs\";\nimport { computed, inject, onBeforeUnmount, provide, ref } from 'vue';\nimport { multipleOpenStrategy, singleOpenStrategy } from \"./openStrategies.mjs\";\nimport { classicSelectStrategy, independentSelectStrategy, independentSingleSelectStrategy, leafSelectStrategy, leafSingleSelectStrategy } from \"./selectStrategies.mjs\"; // Types\n\nexport var VNestedSymbol = Symbol[\"for\"]('vuetify:nested');\nexport var emptyNested = {\n  id: ref(),\n  root: {\n    register: function register() {\n      return null;\n    },\n    unregister: function unregister() {\n      return null;\n    },\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: function open() {\n      return null;\n    },\n    select: function select() {\n      return null;\n    },\n    opened: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([])\n  }\n};\nexport var makeNestedProps = propsFactory({\n  selectStrategy: [String, Function],\n  openStrategy: [String, Function],\n  opened: Array,\n  selected: Array,\n  mandatory: Boolean\n}, 'nested');\nexport var useNested = function useNested(props) {\n  var isUnmounted = false;\n  var children = ref(new Map());\n  var parents = ref(new Map());\n  var opened = useProxiedModel(props, 'opened', props.opened, function (v) {\n    return new Set(v);\n  }, function (v) {\n    return _toConsumableArray(v.values());\n  });\n  var selectStrategy = computed(function () {\n    if (_typeof(props.selectStrategy) === 'object') return props.selectStrategy;\n\n    switch (props.selectStrategy) {\n      case 'single-leaf':\n        return leafSingleSelectStrategy(props.mandatory);\n\n      case 'leaf':\n        return leafSelectStrategy(props.mandatory);\n\n      case 'independent':\n        return independentSelectStrategy(props.mandatory);\n\n      case 'single-independent':\n        return independentSingleSelectStrategy(props.mandatory);\n\n      case 'classic':\n      default:\n        return classicSelectStrategy(props.mandatory);\n    }\n  });\n  var openStrategy = computed(function () {\n    if (typeof props.openStrategy === 'function') return props.openStrategy;\n\n    switch (props.openStrategy) {\n      case 'single':\n        return singleOpenStrategy;\n\n      case 'multiple':\n      default:\n        return multipleOpenStrategy;\n    }\n  });\n  var selected = useProxiedModel(props, 'selected', props.selected, function (v) {\n    return selectStrategy.value[\"in\"](v, children.value, parents.value);\n  }, function (v) {\n    return selectStrategy.value.out(v, children.value, parents.value);\n  });\n  onBeforeUnmount(function () {\n    isUnmounted = true;\n  });\n\n  function getPath(id) {\n    var path = [];\n    var parent = id;\n\n    while (parent != null) {\n      path.unshift(parent);\n      parent = parents.value.get(parent);\n    }\n\n    return path;\n  }\n\n  var vm = getCurrentInstance('nested');\n  var nested = {\n    id: ref(),\n    root: {\n      opened: opened,\n      selected: selected,\n      selectedValues: computed(function () {\n        var arr = [];\n\n        var _iterator = _createForOfIteratorHelper(selected.value.entries()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                key = _step$value[0],\n                value = _step$value[1];\n\n            if (value === 'on') arr.push(key);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return arr;\n      }),\n      register: function register(id, parentId, isGroup) {\n        parentId && id !== parentId && parents.value.set(id, parentId);\n        isGroup && children.value.set(id, []);\n\n        if (parentId != null) {\n          children.value.set(parentId, [].concat(_toConsumableArray(children.value.get(parentId) || []), [id]));\n        }\n      },\n      unregister: function unregister(id) {\n        if (isUnmounted) return;\n        children.value[\"delete\"](id);\n        var parent = parents.value.get(id);\n\n        if (parent) {\n          var _children$value$get;\n\n          var list = (_children$value$get = children.value.get(parent)) != null ? _children$value$get : [];\n          children.value.set(parent, list.filter(function (child) {\n            return child !== id;\n          }));\n        }\n\n        parents.value[\"delete\"](id);\n        opened.value[\"delete\"](id);\n      },\n      open: function open(id, value, event) {\n        vm.emit('click:open', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newOpened = openStrategy.value({\n          id: id,\n          value: value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      select: function select(id, value, event) {\n        vm.emit('click:select', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newSelected = selectStrategy.value.select({\n          id: id,\n          value: value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newSelected && (selected.value = newSelected);\n      },\n      children: children,\n      parents: parents\n    }\n  };\n  provide(VNestedSymbol, nested);\n  return nested.root;\n};\nexport var useNestedItem = function useNestedItem(id, isGroup) {\n  var parent = inject(VNestedSymbol, emptyNested);\n  var computedId = computed(function () {\n    var _id$value;\n\n    return (_id$value = id.value) != null ? _id$value : getUid().toString();\n  });\n\n  var item = _objectSpread(_objectSpread({}, parent), {}, {\n    id: computedId,\n    open: function open(_open, e) {\n      return parent.root.open(computedId.value, _open, e);\n    },\n    isOpen: computed(function () {\n      return parent.root.opened.value.has(computedId.value);\n    }),\n    parent: computed(function () {\n      return parent.root.parents.value.get(computedId.value);\n    }),\n    select: function select(selected, e) {\n      return parent.root.select(computedId.value, selected, e);\n    },\n    isSelected: computed(function () {\n      return parent.root.selected.value.get(computedId.value) === 'on';\n    }),\n    isIndeterminate: computed(function () {\n      return parent.root.selected.value.get(computedId.value) === 'indeterminate';\n    }),\n    isLeaf: computed(function () {\n      return !parent.root.children.value.get(computedId.value);\n    }),\n    isGroupActivator: parent.isGroupActivator\n  });\n\n  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);\n  onBeforeUnmount(function () {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value);\n  });\n  isGroup && provide(VNestedSymbol, item);\n  return item;\n};\nexport var useNestedGroupActivator = function useNestedGroupActivator() {\n  var parent = inject(VNestedSymbol, emptyNested);\n  provide(VNestedSymbol, _objectSpread(_objectSpread({}, parent), {}, {\n    isGroupActivator: true\n  }));\n};","map":{"version":3,"mappings":"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","names":["useProxiedModel","getCurrentInstance","getUid","propsFactory","computed","inject","onBeforeUnmount","provide","ref","multipleOpenStrategy","singleOpenStrategy","classicSelectStrategy","independentSelectStrategy","independentSingleSelectStrategy","leafSelectStrategy","leafSingleSelectStrategy","VNestedSymbol","Symbol","emptyNested","id","root","register","unregister","parents","Map","children","open","select","opened","Set","selected","selectedValues","makeNestedProps","selectStrategy","String","Function","openStrategy","Array","mandatory","Boolean","useNested","props","isUnmounted","v","values","value","out","getPath","path","parent","unshift","get","vm","nested","arr","entries","key","push","parentId","isGroup","set","list","filter","child","event","emit","newOpened","newSelected","useNestedItem","computedId","toString","item","e","isOpen","has","isSelected","isIndeterminate","isLeaf","isGroupActivator","useNestedGroupActivator"],"sources":["../../../src/composables/nested/nested.ts"],"sourcesContent":["import { useProxiedModel } from '@/composables/proxiedModel'\nimport { getCurrentInstance, getUid, propsFactory } from '@/util'\nimport { computed, inject, onBeforeUnmount, provide, ref } from 'vue'\nimport { multipleOpenStrategy, singleOpenStrategy } from './openStrategies'\nimport {\n  classicSelectStrategy,\n  independentSelectStrategy,\n  independentSingleSelectStrategy,\n  leafSelectStrategy,\n  leafSingleSelectStrategy,\n} from './selectStrategies'\n\n// Types\nimport type { InjectionKey, Prop, Ref } from 'vue'\nimport type { SelectStrategyFn } from './selectStrategies'\nimport type { OpenStrategyFn } from './openStrategies'\n\nexport type SelectStrategy = 'single-leaf' | 'leaf' | 'independent' | 'single-independent' | 'classic' | SelectStrategyFn\nexport type OpenStrategy = 'single' | 'multiple' | OpenStrategyFn\n\nexport interface NestedProps {\n  selectStrategy: SelectStrategy | undefined\n  openStrategy: OpenStrategy | undefined\n  selected: string[] | undefined\n  opened: string[] | undefined\n  mandatory: boolean\n  'onUpdate:selected': ((val: string[]) => void) | undefined\n  'onUpdate:opened': ((val: string[]) => void) | undefined\n}\n\ntype NestedProvide = {\n  id: Ref<string | undefined>\n  isGroupActivator?: boolean\n  root: {\n    children: Ref<Map<string, string[]>>\n    parents: Ref<Map<string, string>>\n    opened: Ref<Set<string>>\n    selected: Ref<Map<string, 'on' | 'off' | 'indeterminate'>>\n    selectedValues: Ref<string[]>\n    register: (id: string, parentId: string | undefined, isGroup?: boolean) => void\n    unregister: (id: string) => void\n    open: (id: string, value: boolean, event?: Event) => void\n    select: (id: string, value: boolean, event?: Event) => void\n  }\n}\n\nexport const VNestedSymbol: InjectionKey<NestedProvide> = Symbol.for('vuetify:nested')\n\nexport const emptyNested: NestedProvide = {\n  id: ref(),\n  root: {\n    register: () => null,\n    unregister: () => null,\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: () => null,\n    select: () => null,\n    opened: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([]),\n  },\n}\n\nexport const makeNestedProps = propsFactory({\n  selectStrategy: [String, Function] as Prop<SelectStrategy>,\n  openStrategy: [String, Function] as Prop<OpenStrategy>,\n  opened: Array as Prop<string[]>,\n  selected: Array as Prop<string[]>,\n  mandatory: Boolean,\n}, 'nested')\n\nexport const useNested = (props: NestedProps) => {\n  let isUnmounted = false\n  const children = ref(new Map<string, string[]>())\n  const parents = ref(new Map<string, string>())\n\n  const opened = useProxiedModel(props, 'opened', props.opened, v => new Set(v), v => [...v.values()])\n\n  const selectStrategy = computed(() => {\n    if (typeof props.selectStrategy === 'object') return props.selectStrategy\n\n    switch (props.selectStrategy) {\n      case 'single-leaf': return leafSingleSelectStrategy(props.mandatory)\n      case 'leaf': return leafSelectStrategy(props.mandatory)\n      case 'independent': return independentSelectStrategy(props.mandatory)\n      case 'single-independent': return independentSingleSelectStrategy(props.mandatory)\n      case 'classic':\n      default: return classicSelectStrategy(props.mandatory)\n    }\n  })\n\n  const openStrategy = computed(() => {\n    if (typeof props.openStrategy === 'function') return props.openStrategy\n\n    switch (props.openStrategy) {\n      case 'single': return singleOpenStrategy\n      case 'multiple':\n      default: return multipleOpenStrategy\n    }\n  })\n\n  const selected = useProxiedModel(\n    props,\n    'selected',\n    props.selected,\n    v => selectStrategy.value.in(v, children.value, parents.value),\n    v => selectStrategy.value.out(v, children.value, parents.value),\n  )\n\n  onBeforeUnmount(() => {\n    isUnmounted = true\n  })\n\n  function getPath (id: string) {\n    const path: string[] = []\n    let parent: string | undefined = id\n\n    while (parent != null) {\n      path.unshift(parent)\n      parent = parents.value.get(parent)\n    }\n\n    return path\n  }\n\n  const vm = getCurrentInstance('nested')\n\n  const nested: NestedProvide = {\n    id: ref(),\n    root: {\n      opened,\n      selected,\n      selectedValues: computed(() => {\n        const arr = []\n\n        for (const [key, value] of selected.value.entries()) {\n          if (value === 'on') arr.push(key)\n        }\n\n        return arr\n      }),\n      register: (id, parentId, isGroup) => {\n        parentId && id !== parentId && parents.value.set(id, parentId)\n\n        isGroup && children.value.set(id, [])\n\n        if (parentId != null) {\n          children.value.set(parentId, [...children.value.get(parentId) || [], id])\n        }\n      },\n      unregister: id => {\n        if (isUnmounted) return\n\n        children.value.delete(id)\n        const parent = parents.value.get(id)\n        if (parent) {\n          const list = children.value.get(parent) ?? []\n          children.value.set(parent, list.filter(child => child !== id))\n        }\n        parents.value.delete(id)\n        opened.value.delete(id)\n      },\n      open: (id, value, event) => {\n        vm.emit('click:open', { id, value, path: getPath(id), event })\n\n        const newOpened = openStrategy.value({\n          id,\n          value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        newOpened && (opened.value = newOpened)\n      },\n      select: (id, value, event) => {\n        vm.emit('click:select', { id, value, path: getPath(id), event })\n\n        const newSelected = selectStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n        newSelected && (selected.value = newSelected)\n      },\n      children,\n      parents,\n    },\n  }\n\n  provide(VNestedSymbol, nested)\n\n  return nested.root\n}\n\nexport const useNestedItem = (id: Ref<string | undefined>, isGroup: boolean) => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  const computedId = computed(() => id.value ?? getUid().toString())\n\n  const item = {\n    ...parent,\n    id: computedId,\n    open: (open: boolean, e: Event) => parent.root.open(computedId.value, open, e),\n    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),\n    parent: computed(() => parent.root.parents.value.get(computedId.value)),\n    select: (selected: boolean, e?: Event) => parent.root.select(computedId.value, selected, e),\n    isSelected: computed(() => parent.root.selected.value.get(computedId.value) === 'on'),\n    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === 'indeterminate'),\n    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),\n    isGroupActivator: parent.isGroupActivator,\n  }\n\n  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup)\n\n  onBeforeUnmount(() => {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value)\n  })\n\n  isGroup && provide(VNestedSymbol, item)\n\n  return item\n}\n\nexport const useNestedGroupActivator = () => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  provide(VNestedSymbol, { ...parent, isGroupActivator: true })\n}\n"]},"metadata":{},"sourceType":"module"}